#!/usr/bin/env python3
"""High verbosity account management CLI for MailAI.

This script is responsible for every manual operation that touches the MailAI
configuration regarding IMAP accounts.  The user explicitly requested verbose
inline documentation, therefore every step is annotated to describe *what* the
code does and *why* it exists.  The core features exposed by the CLI are:

* discovering configuration/secrets directories while allowing overrides via
  environment variables (the Docker deployment injects those),
* generating a JSON template describing the mail categories that the AI model
  manipulates ("important", "newsletter", etc.),
* ensuring all file writes are atomic to avoid corrupting the YAML/JSON files
  if the device powers off unexpectedly, and
* offering five subcommands (``add``, ``update``, ``remove``, ``list`` and
  ``test``) for day-to-day account administration.

The logic sticks to straightforward data manipulation and favours clarity over
clever tricks so that operators can easily audit the actions performed by the
script.
"""

import argparse
import getpass
import json
import os
import re
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

import yaml
from imapclient import IMAPClient

# Lightweight cache for the local encoder so repeated runs avoid reloading the
# model from disk.
_ENCODER_CACHE = {}

# ---------------------------------------------------------------------------
# Configuration paths
# ---------------------------------------------------------------------------
# ``APP_CONFIG`` lets the caller override where the YAML configuration lives.
# The default matches the location used inside the Docker container.
CFG_PATH = Path(os.environ.get("APP_CONFIG", "/config/config.yml"))

# Secrets (one file per account containing the IMAP password) live under this
# directory.  We centralise the path so every function writes to the same
# location and so the directory can be created lazily when needed.
SECRETS_DIR = Path("/config/secrets")

# JSON description files describing the MailAI category prompts and mapping are
# stored here.  ``MAIL_TYPES_DIR`` mirrors the setting used by the main app.
MAIL_TYPES_DIR = Path(os.environ.get("MAIL_TYPES_DIR", "/config/account_types"))

# ---------------------------------------------------------------------------
# Generic prompt templates
# ---------------------------------------------------------------------------
# Each mail type gets a French description that is embedded into the JSON file.
# Those prompts are consumed by MailAI to explain to the language model what it
# should detect.  They also provide documentation for operators reading the
# files on disk.
GENERIC_PROMPTS = {
    "important": (
        "Classer dans le dossier Important tout message nécessitant une action rapide, "
        "lié à des responsables, des clients ou des demandes urgentes."
    ),
    "newsletter": (
        "Identifier les newsletters, campagnes marketing, promotions commerciales et les "
        "emails automatisés d'information générique."
    ),
    "projet": (
        "Détecter les emails liés aux projets en cours : échanges d'équipe, comptes rendus, "
        "plans d'action, livrables ou demandes de suivi."
    ),
    "basse": (
        "Repérer les notifications de réseaux sociaux, invitations automatiques et autres "
        "messages de faible priorité."
    ),
    "quarantine": (
        "Utiliser la quarantaine pour tout message ambigu ou incertain afin d'attendre une "
        "revue manuelle."
    ),
    "factures": (
        "Repérer les mails contenant une facture à traiter : expéditeur de type fournisseur, "
        "mention explicite de facture ou facturation et présence d'une pièce jointe PDF."
    ),
}

# ---------------------------------------------------------------------------
# Folder intent prompts for the local LLM / encoder
# ---------------------------------------------------------------------------

FOLDER_INTENT_PROMPTS = [
    {
        "key": "spam",
        "label": "Courrier indésirable / Spam",
        "description": (
            "Dossier pour le courrier indésirable, les spams, pourriels et messages"
            " suspects qui doivent être isolés du reste de la boîte de réception."
        ),
        "aliases": [
            "spam",
            "junk",
            "pourriel",
            "indesirable",
            "indésirable",
            "courrier indesirable",
            "junk mail",
            "trash",
        ],
    },
    {
        "key": "quarantine",
        "label": "Quarantaine / Revue manuelle",
        "description": (
            "Dossier intermédiaire pour les messages ambigus nécessitant une revue"
            " humaine avant décision finale."
        ),
        "aliases": ["quarantaine", "review", "a-review", "to review"],
    },
    {
        "key": "important",
        "label": "Important / Prioritaire",
        "description": (
            "Dossier réservé aux messages critiques, clients prioritaires ou"
            " nécessitant une action rapide."
        ),
        "aliases": ["important", "prioritaire", "urgent", "high priority"],
    },
    {
        "key": "newsletter",
        "label": "Newsletters / Promotions",
        "description": (
            "Dossier dédié aux newsletters, promotions marketing, campagnes"
            " commerciales et emails automatisés d'information."
        ),
        "aliases": [
            "newsletter",
            "promotions",
            "promo",
            "marketing",
            "mailing list",
        ],
    },
    {
        "key": "projet",
        "label": "Projets / Gestion d'équipe",
        "description": (
            "Dossier lié aux projets en cours : échanges d'équipe, suivi de livrables"
            " ou coordination de missions."
        ),
        "aliases": ["projet", "project", "projects", "team", "mission"],
    },
    {
        "key": "basse",
        "label": "Faible priorité / Réseaux sociaux",
        "description": (
            "Dossier pour les notifications sociales, alertes automatiques et autres"
            " messages de faible importance."
        ),
        "aliases": ["social", "reseaux", "réseaux", "low priority", "notifications"],
    },
    {
        "key": "archive_general",
        "label": "Archive générale",
        "description": (
            "Dossier servant à archiver les messages traités ou terminés pour"
            " conserver un historique."
        ),
        "aliases": ["archive", "archives", "archivés", "archived", "historique"],
    },
    {
        "key": "archive_factures",
        "label": "Archive factures / Comptabilité",
        "description": (
            "Dossier d'archivage dédié aux factures, documents comptables ou"
            " pièces jointes financières."
        ),
        "aliases": ["facture", "factures", "invoice", "invoices", "compta", "billing"],
    },
    {
        "key": "clients",
        "label": "Clients / Comptes clés",
        "description": (
            "Dossier consacré aux clients, prospects, comptes clés ou échanges"
            " commerciaux importants."
        ),
        "aliases": ["client", "clients", "customer", "customers", "crm", "prospect"],
    },
    {
        "key": "support",
        "label": "Support / Tickets",
        "description": (
            "Dossier pour les tickets de support, demandes d'assistance ou suivi"
            " de SAV."
        ),
        "aliases": ["support", "sav", "helpdesk", "ticket", "assistance"],
    },
    {
        "key": "orders",
        "label": "Commandes / e-commerce",
        "description": (
            "Dossier regroupant les commandes, confirmations d'achat ou"
            " notifications d'expédition."
        ),
        "aliases": ["commande", "commandes", "order", "orders", "shop", "ecommerce"],
    },
]

FOLDER_SUGGESTION_THRESHOLD = 0.58


# ---------------------------------------------------------------------------
# File helpers
# ---------------------------------------------------------------------------

def _write_mail_types(path: Path, payload: dict) -> None:
    """Persist the mail-types payload to disk while remaining crash-safe.

    The file is written through a ``.tmp`` suffix and then atomically moved in
    place with ``os.replace``.  This ensures there is never a partially written
    JSON file if the Raspberry Pi loses power mid-operation.
    """

    # Update a metadata field so operators know when the file was generated.
    payload["updated_at"] = datetime.utcnow().isoformat()

    # Guarantee the destination directory exists (``mkdir`` is idempotent).
    path.parent.mkdir(parents=True, exist_ok=True)
    tmp = path.with_suffix(path.suffix + ".tmp")

    # Dump the JSON in UTF-8 while keeping accents readable (``ensure_ascii``).
    with open(tmp, "w", encoding="utf-8") as fh:
        json.dump(payload, fh, indent=2, ensure_ascii=False)

    # ``os.replace`` performs an atomic rename on POSIX systems.
    os.replace(tmp, path)


def _sync_targets(payload: dict, mapping_targets: dict, spam_folder: str, quarantine_folder: str) -> None:
    """Adjust target folders for each mail type using the provided mapping."""

    for entry in payload.get("types", []):
        key = entry.get("key")

        # ``spam`` and ``quarantine`` are forced to use the dedicated folders so
        # the model cannot accidentally move them elsewhere.
        if key == "spam" and spam_folder:
            entry["target_folder"] = spam_folder
        elif key == "quarantine" and quarantine_folder:
            entry["target_folder"] = quarantine_folder

        # Optional targets (important/newsletter/…) rely on the mapping if the
        # caller provided one.
        elif key in mapping_targets and mapping_targets.get(key):
            entry["target_folder"] = mapping_targets[key]

        # Invoices default to the "projet" folder, otherwise fall back to
        # quarantine or spam so that documents are not left unclassified.
        elif key == "factures" and not entry.get("target_folder"):
            entry["target_folder"] = (
                mapping_targets.get("projet")
                or quarantine_folder
                or spam_folder
            )


def ensure_mail_types(
    name: str,
    mapping_targets: dict,
    spam_folder: str,
    quarantine_folder: str,
    existing_path: Optional[str] = None,
) -> Path:
    """Create or merge the JSON file driving MailAI category mappings.

    When ``existing_path`` is provided the function loads it and appends any
    missing defaults so that upgrades remain backwards compatible.  Otherwise a
    fresh payload is generated using :data:`GENERIC_PROMPTS`.
    """

    # ``base_payload`` contains every known mail type with a sensible default.
    base_payload = {
        "account": name,
        "version": 1,
        "types": [
            {
                "key": "important",
                "label": "Important",
                "enabled": True,
                "target_folder": mapping_targets.get("important"),
                "prompt": GENERIC_PROMPTS["important"],
            },
            {
                "key": "newsletter",
                "label": "Newsletters",
                "enabled": False,
                "target_folder": mapping_targets.get("newsletter"),
                "prompt": GENERIC_PROMPTS["newsletter"],
            },
            {
                "key": "projet",
                "label": "Projets",
                "enabled": False,
                "target_folder": mapping_targets.get("projet"),
                "prompt": GENERIC_PROMPTS["projet"],
            },
            {
                "key": "basse",
                "label": "Faible priorité",
                "enabled": False,
                "target_folder": mapping_targets.get("basse"),
                "prompt": GENERIC_PROMPTS["basse"],
            },
            {
                "key": "quarantine",
                "label": "Quarantaine",
                "enabled": False,
                "target_folder": quarantine_folder,
                "prompt": GENERIC_PROMPTS["quarantine"],
            },
            {
                "key": "factures",
                "label": "Factures à traiter",
                "enabled": False,
                "target_folder": mapping_targets.get("projet") or quarantine_folder,
                "prompt": GENERIC_PROMPTS["factures"],
            },
        ],
    }

    # Either reuse the existing JSON (update flow) or create a new file next to
    # the other account definitions.
    path = Path(existing_path) if existing_path else MAIL_TYPES_DIR / f"{name}.json"
    if path.exists():
        with open(path, "r", encoding="utf-8") as fh:
            payload = json.load(fh)
        existing_keys = {t.get("key") for t in payload.get("types", [])}
        for entry in base_payload["types"]:
            if entry["key"] not in existing_keys:
                payload.setdefault("types", []).append(entry)
    else:
        payload = base_payload

    _sync_targets(payload, mapping_targets, spam_folder, quarantine_folder)
    _write_mail_types(path, payload)
    return path


# ---------------------------------------------------------------------------
# Folder intent analysis
# ---------------------------------------------------------------------------

def _load_local_encoder(enc_name: str):
    """Load the local SentenceTransformer encoder used for intent inference."""

    if not enc_name:
        return None

    encoder = _ENCODER_CACHE.get(enc_name)
    if encoder is not None:
        return encoder

    try:
        from sentence_transformers import SentenceTransformer
    except ImportError as exc:  # pragma: no cover - dependency missing on host
        print(
            f"[WARN] sentence-transformers unavailable: folder analysis disabled ({exc})",
            file=sys.stderr,
        )
        return None

    print(f"[LLM] loading local encoder '{enc_name}' for folder analysis…")
    encoder = SentenceTransformer(enc_name)
    _ENCODER_CACHE[enc_name] = encoder
    return encoder


def _aliases_for(folder: str) -> str:
    """Return a lowercase helper string for alias matching."""

    return re.sub(r"[^a-z0-9]+", " ", (folder or "").lower()).strip()


def analyse_folder_intents(existing_folders, cfg, delim: str):
    """Infer probable usage for folders using the local embedding model."""

    folders = []
    for raw in sorted(existing_folders):
        if not raw:
            continue
        name = _to_str(raw)
        if not name or name.upper() == "INBOX":
            continue
        folders.append(name)

    if not folders:
        return {}

    enc_name = ((cfg.get("model") or {}).get("encoder") if isinstance(cfg, dict) else None)
    if not enc_name:
        enc_name = "sentence-transformers/all-MiniLM-L6-v2"

    encoder = _load_local_encoder(enc_name)
    if encoder is None:
        return {}

    try:
        import numpy as np
    except ImportError as exc:  # pragma: no cover - dependency missing on host
        print(f"[WARN] numpy unavailable: folder analysis disabled ({exc})", file=sys.stderr)
        return {}

    prompt_texts = [entry["description"] for entry in FOLDER_INTENT_PROMPTS]
    folder_texts = []
    alias_helpers = []
    for folder in folders:
        clean = folder.replace(delim, " ")
        clean = re.sub(r"[_.-]+", " ", clean)
        folder_texts.append(f"Dossier email nommé '{clean}'.")
        alias_helpers.append(_aliases_for(folder))

    prompt_vectors = encoder.encode(
        prompt_texts,
        show_progress_bar=False,
        normalize_embeddings=True,
    )
    folder_vectors = encoder.encode(
        folder_texts,
        show_progress_bar=False,
        normalize_embeddings=True,
    )

    scores = np.matmul(folder_vectors, prompt_vectors.T)

    analysis = {
        "encoder": enc_name,
        "generated_at": datetime.utcnow().isoformat(),
        "folders": {},
    }

    for idx, folder in enumerate(folders):
        row = scores[idx]
        matches = []
        alias_base = alias_helpers[idx]
        for prompt_idx, prompt in enumerate(FOLDER_INTENT_PROMPTS):
            base_score = float(row[prompt_idx])
            alias_hit = None
            for alias in prompt.get("aliases", []):
                normalized = alias.lower().strip()
                if normalized and normalized in alias_base:
                    alias_hit = alias
                    base_score += 0.2
                    break
            match = {
                "key": prompt["key"],
                "label": prompt["label"],
                "score": round(min(max(base_score, -1.0), 1.0), 4),
            }
            if alias_hit:
                match["alias"] = alias_hit
            matches.append(match)

        matches.sort(key=lambda entry: entry["score"], reverse=True)
        analysis["folders"][folder] = matches[:5]

    return analysis


def suggest_folder_for_role(analysis: dict, role: str, threshold: float = FOLDER_SUGGESTION_THRESHOLD):
    """Return the folder that best matches ``role`` according to the analysis."""

    if not analysis:
        return None

    folders = analysis.get("folders", {})
    best_folder = None
    best_score = threshold
    alias_priority = False

    for folder, matches in folders.items():
        for entry in matches:
            if entry.get("key") != role:
                continue
            score = entry.get("score", 0.0)
            alias_hit = bool(entry.get("alias"))
            if alias_hit:
                if not alias_priority or score > best_score:
                    best_folder = folder
                    best_score = score
                    alias_priority = True
            elif not alias_priority and score > best_score:
                best_folder = folder
                best_score = score

    return best_folder


# ---------------------------------------------------------------------------
# Configuration helpers
# ---------------------------------------------------------------------------

def load_cfg():
    """Read ``config.yml`` from disk and abort if the file is missing."""

    if not CFG_PATH.exists():
        print(f"Config not found: {CFG_PATH}", file=sys.stderr)
        sys.exit(2)

    with open(CFG_PATH, "r", encoding="utf-8") as fh:
        return yaml.safe_load(fh)


def save_cfg(cfg) -> None:
    """Write ``config.yml`` atomically to prevent corruption."""

    tmp = CFG_PATH.with_suffix(".tmp")
    with open(tmp, "w", encoding="utf-8") as fh:
        yaml.safe_dump(cfg, fh, sort_keys=False, allow_unicode=True)
    os.replace(tmp, CFG_PATH)


def norm_name(name: str) -> str:
    """Sanitise the account name so it is safe for filenames and YAML keys."""

    return re.sub(r"[^a-zA-Z0-9_-]+", "", name.strip())


def find_acc(cfg, name: str) -> Tuple[Optional[int], Optional[dict]]:
    """Locate an account inside the configuration and return its index."""

    for idx, account in enumerate(cfg.get("accounts", [])):
        if account.get("name") == name:
            return idx, account
    return None, None


def test_imap(host, port, ssl, user, pwd):
    """Check IMAP credentials by logging in and selecting the INBOX."""

    with IMAPClient(host, port=int(port), ssl=bool(ssl)) as srv:
        srv.login(user, pwd)
        srv.select_folder("INBOX", readonly=True)
    return True, None


# ---------------------------------------------------------------------------
# IMAP folder helpers
# ---------------------------------------------------------------------------

def _to_str(value):
    """Best-effort decoding helper for IMAP folder names."""

    if isinstance(value, bytes):
        try:
            return value.decode("utf-8", "ignore")
        except Exception:
            return value.decode("latin-1", "ignore")
    return value


def detect_mailbox_style(srv):
    """Inspect the IMAP hierarchy to discover delimiters and namespaces."""

    folders = srv.list_folders()
    delim_raw = next((delim for _flags, delim, _name in folders if delim), "/")
    delim = _to_str(delim_raw) or "/"
    existing = {_to_str(name) for _flags, _delim, name in folders}
    has_inbox_ns = any(name.upper().startswith(f"INBOX{delim}") for name in existing)
    return delim, has_inbox_ns, existing


def normalize_folder(user_str, delim, has_inbox_ns):
    """Convert user-provided folder names to the server convention."""

    name = (user_str or "").strip()
    if not name:
        return name

    upper = name.upper()
    if upper.startswith("INBOX/") or upper.startswith("INBOX."):
        return name.replace("/", delim).replace(".", delim)

    name = name.replace("/", delim).replace(".", delim)
    if has_inbox_ns:
        name = f"INBOX{delim}{name}"
    return name


def ensure_folders(srv, targets, existing):
    """Create the IMAP folders that do not exist yet and report them."""

    created = []
    for box in targets:
        if not box:
            continue
        if box not in existing:
            try:
                srv.create_folder(box)
                created.append(box)
                existing.add(box)
            except Exception as exc:
                print(f"[WARN] create {box}: {exc}", file=sys.stderr)
    return created


# ---------------------------------------------------------------------------
# CLI handlers
# ---------------------------------------------------------------------------

def add_account(args):
    """Handle ``accountctl add``."""

    if not args.host:
        print("[ERROR] --host is required (no default).", file=sys.stderr)
        sys.exit(2)

    cfg = load_cfg()
    accounts = cfg.setdefault("accounts", [])
    name = norm_name(args.name)
    if not name:
        print("Invalid account name", file=sys.stderr)
        sys.exit(2)
    if any(acc.get("name") == name for acc in accounts):
        print(f"Account '{name}' already exists.", file=sys.stderr)
        sys.exit(2)

    SECRETS_DIR.mkdir(parents=True, exist_ok=True)
    secret_file = SECRETS_DIR / f"{name}.pass"

    user = args.user or input("IMAP username (email): ").strip()
    password = args.password or getpass.getpass("IMAP password: ")

    folder_analysis = {}

    try:
        with IMAPClient(args.host, port=int(args.port), ssl=not args.no_ssl) as srv:
            srv.login(user, password)
            delim, has_inbox_ns, existing = detect_mailbox_style(srv)

            folder_analysis = analyse_folder_intents(existing, cfg, delim)
            if folder_analysis.get("folders"):
                print("[INFO] Folder intent analysis (local encoder):")
                for folder, matches in folder_analysis["folders"].items():
                    top = matches[0]
                    extras = ", ".join(
                        f"{entry['label']} {entry['score']:.2f}"
                        for entry in matches[1:3]
                    )
                    suffix = f" | {extras}" if extras else ""
                    alias_note = f" (alias: {top['alias']})" if top.get("alias") else ""
                    print(
                        f"  - {folder}: {top['label']} {top['score']:.2f}{alias_note}{suffix}"
                    )

            # Provide defaults for the various folders but allow CLI overrides.
            spam_f = args.spam or "Junk"
            important_f = args.important or "Important"
            newsletter_f = args.newsletter or "Promotions"
            projet_f = args.projet or "Projects"
            basse_f = args.basse or "SocialNetwork"
            quarantine_f = args.quarantine or "AI/A-REVIEW"

            if not args.spam:
                suggested = suggest_folder_for_role(folder_analysis, "spam")
                if suggested:
                    spam_f = suggested
                    print(f"[INFO] Using suggested spam folder: {spam_f}")
            if not args.important:
                suggested = suggest_folder_for_role(folder_analysis, "important")
                if suggested:
                    important_f = suggested
                    print(f"[INFO] Using suggested important folder: {important_f}")
            if not args.newsletter:
                suggested = suggest_folder_for_role(folder_analysis, "newsletter")
                if suggested:
                    newsletter_f = suggested
                    print(f"[INFO] Using suggested newsletter folder: {newsletter_f}")
            if not args.projet:
                suggested = suggest_folder_for_role(folder_analysis, "projet")
                if suggested:
                    projet_f = suggested
                    print(f"[INFO] Using suggested project folder: {projet_f}")
            if not args.basse:
                suggested = suggest_folder_for_role(folder_analysis, "basse")
                if suggested:
                    basse_f = suggested
                    print(f"[INFO] Using suggested low-priority folder: {basse_f}")
            if not args.quarantine:
                suggested = suggest_folder_for_role(folder_analysis, "quarantine")
                if suggested:
                    quarantine_f = suggested
                    print(f"[INFO] Using suggested quarantine folder: {quarantine_f}")

            spam_f_n = normalize_folder(spam_f, delim, has_inbox_ns)
            important_f_n = normalize_folder(important_f, delim, has_inbox_ns)
            newsletter_f_n = normalize_folder(newsletter_f, delim, has_inbox_ns)
            projet_f_n = normalize_folder(projet_f, delim, has_inbox_ns)
            basse_f_n = normalize_folder(basse_f, delim, has_inbox_ns)
            quarantine_f_n = normalize_folder(quarantine_f, delim, has_inbox_ns)

            if not args.no_create_folders:
                to_create = [
                    folder
                    for folder in [spam_f_n, important_f_n, newsletter_f_n, projet_f_n, basse_f_n, quarantine_f_n]
                    if folder
                ]
                created = ensure_folders(srv, to_create, existing)
                if created:
                    print("[OK] Created folders:", ", ".join(created))

            mapping_targets = {
                "important": important_f_n,
                "newsletter": newsletter_f_n,
                "projet": projet_f_n,
                "basse": basse_f_n,
                "quarantine": quarantine_f_n,
            }
    except Exception as exc:
        print(f"[ERROR] IMAP connection or folder setup: {exc}", file=sys.stderr)
        sys.exit(1)

    secret_file.write_text(password)
    os.chmod(secret_file, 0o600)

    types_path = ensure_mail_types(name, mapping_targets, spam_f_n, quarantine_f_n)

    if folder_analysis:
        suggestions = {
            key: suggest_folder_for_role(folder_analysis, key)
            for key in ["spam", "important", "newsletter", "projet", "basse", "quarantine"]
        }
        folder_analysis = {
            "encoder": folder_analysis.get("encoder"),
            "generated_at": folder_analysis.get("generated_at"),
            "folders": folder_analysis.get("folders", {}),
            "suggestions": {k: v for k, v in suggestions.items() if v},
        }

    new_account = {
        "name": name,
        "imap": {
            "host": args.host,
            "port": int(args.port),
            "ssl": not args.no_ssl,
            "user": user,
            "password_file": str(secret_file),
        },
        "mode": {
            "auto_move": bool(args.auto_move),
            "auto_spam": bool(args.auto_spam),
        },
        "folders": {
            "inbox": "INBOX",
            "spam": spam_f_n,
            "targets": mapping_targets,
        },
        "mail_types_config": str(types_path),
        "rules": [],
    }

    if folder_analysis:
        new_account.setdefault("analysis", {})["folder_intents"] = folder_analysis

    accounts.append(new_account)
    save_cfg(cfg)

    print(f"[OK] Account '{name}' added ({user}@{args.host}). Secret: {secret_file}")
    print("Folders mapping (normalized):")
    print(f"  Spam        -> {spam_f_n}")
    print(f"  Important   -> {mapping_targets['important']}")
    print(f"  Promotions  -> {mapping_targets['newsletter']}")
    print(f"  Projects    -> {mapping_targets['projet']}")
    print(f"  Social/Low  -> {mapping_targets['basse']}")
    print(f"  Quarantine  -> {mapping_targets['quarantine']}")


def update_account(args):
    """Handle ``accountctl update``."""

    cfg = load_cfg()
    idx, account = find_acc(cfg, args.name)
    if account is None:
        print(f"Account '{args.name}' not found.", file=sys.stderr)
        sys.exit(2)

    if args.user:
        account["imap"]["user"] = args.user
    if args.host:
        account["imap"]["host"] = args.host
    if args.port:
        account["imap"]["port"] = int(args.port)
    if args.no_ssl is True:
        account["imap"]["ssl"] = False
    if args.ssl is True:
        account["imap"]["ssl"] = True

    if any([args.spam, args.important, args.newsletter, args.projet, args.basse, args.quarantine]):
        password = Path(account["imap"]["password_file"]).read_text().strip()
        with IMAPClient(account["imap"]["host"], port=account["imap"]["port"], ssl=account["imap"].get("ssl", True)) as srv:
            srv.login(account["imap"]["user"], password)
            delim, has_inbox_ns, existing = detect_mailbox_style(srv)

            def normalise(value):
                return normalize_folder(value, delim, has_inbox_ns) if value else None

            if args.spam:
                account["folders"]["spam"] = normalise(args.spam)
            targets = account.get("folders", {}).setdefault("targets", {})
            if args.important:
                targets["important"] = normalise(args.important)
            if args.newsletter:
                targets["newsletter"] = normalise(args.newsletter)
            if args.projet:
                targets["projet"] = normalise(args.projet)
            if args.basse:
                targets["basse"] = normalise(args.basse)
            if args.quarantine:
                targets["quarantine"] = normalise(args.quarantine)

            to_create = [account["folders"].get("spam")] + list(targets.values())
            to_create = [folder for folder in to_create if folder]
            if not args.no_create_folders:
                created = ensure_folders(srv, to_create, existing)
                if created:
                    print("[OK] Created folders:", ", ".join(created))

    account.setdefault("mode", {})
    if args.auto_move:
        account["mode"]["auto_move"] = True
    if args.no_move:
        account["mode"]["auto_move"] = False
    if args.auto_spam:
        account["mode"]["auto_spam"] = True
    if args.no_spam:
        account["mode"]["auto_spam"] = False

    targets = account.get("folders", {}).setdefault("targets", {})
    spam_folder = account.get("folders", {}).get("spam")
    quarantine_folder = targets.get("quarantine")
    types_path = ensure_mail_types(args.name, targets, spam_folder, quarantine_folder, account.get("mail_types_config"))
    account["mail_types_config"] = str(types_path)

    if args.rotate_password:
        secret_path = Path(account["imap"]["password_file"])
        SECRETS_DIR.mkdir(parents=True, exist_ok=True)
        if not secret_path.parent.exists():
            secret_path = SECRETS_DIR / f"{args.name}.pass"
            account["imap"]["password_file"] = str(secret_path)
        new_password = getpass.getpass("New IMAP password: ")
        test_imap(account["imap"]["host"], account["imap"]["port"], account["imap"]["ssl"], account["imap"]["user"], new_password)
        secret_path.write_text(new_password)
        os.chmod(secret_path, 0o600)
        print("[OK] Password updated.")

    save_cfg(cfg)
    print(f"[OK] Account '{args.name}' updated.")


def remove_account(args):
    """Handle ``accountctl remove``."""

    cfg = load_cfg()
    idx, account = find_acc(cfg, args.name)
    if account is None:
        print(f"Account '{args.name}' not found.", file=sys.stderr)
        sys.exit(2)

    secret = account["imap"].get("password_file")
    types_cfg = account.get("mail_types_config")
    del cfg["accounts"][idx]
    save_cfg(cfg)

    if args.delete_secret and secret:
        try:
            Path(secret).unlink()
            print(f"[OK] Secret removed: {secret}")
        except FileNotFoundError:
            pass

    if types_cfg:
        try:
            Path(types_cfg).unlink()
            print(f"[OK] Mail types config removed: {types_cfg}")
        except FileNotFoundError:
            pass

    print(f"[OK] Account '{args.name}' removed.")


def list_accounts(_args):
    """Handle ``accountctl list``."""

    cfg = load_cfg()
    accounts = cfg.get("accounts", [])
    if not accounts:
        print("(no accounts)")
        return

    for account in accounts:
        targets = account.get("folders", {}).get("targets", {})
        print(
            f"- {account['name']}: {account['imap']['user']} @ {account['imap']['host']}:{account['imap']['port']} "
            f"ssl={account['imap'].get('ssl', True)} auto_move={account.get('mode', {}).get('auto_move', False)} "
            f"auto_spam={account.get('mode', {}).get('auto_spam', False)} "
            f"[Spam={account['folders'].get('spam')}, Important={targets.get('important')}, "
            f"Promotions={targets.get('newsletter')}, Social={targets.get('basse')}, "
            f"Projects={targets.get('projet')}, Quarantine={targets.get('quarantine')}]"
        )
        if account.get("mail_types_config"):
            print(f"    mail_types_config={account['mail_types_config']}")


def test_account(args):
    """Handle ``accountctl test``."""

    cfg = load_cfg()
    _idx, account = find_acc(cfg, args.name)
    if account is None:
        print(f"Account '{args.name}' not found.", file=sys.stderr)
        sys.exit(2)

    user = account["imap"]["user"]
    host = account["imap"]["host"]
    port = account["imap"]["port"]
    ssl = account["imap"].get("ssl", True)
    password = Path(account["imap"]["password_file"]).read_text().strip()

    test_imap(host, port, ssl, user, password)
    print(f"[OK] IMAP connection for '{args.name}' succeeded.")


def main():
    """Parse CLI arguments and dispatch to the appropriate handler."""

    ap = argparse.ArgumentParser(description="Account management for RPi-MailAI")
    sub = ap.add_subparsers(dest="cmd", required=True)

    ap_add = sub.add_parser("add", help="Add an IMAP account (creates/normalizes folders)")
    ap_add.add_argument("name", help="Internal account name (e.g., work, personal2)")
    ap_add.add_argument("--user", required=True, help="IMAP username (email)")
    ap_add.add_argument("--host", required=True, help="IMAP server hostname (required)")
    ap_add.add_argument("--port", default=993)
    ap_add.add_argument("--no-ssl", action="store_true", help="Disable SSL (not recommended)")
    ap_add.add_argument("--password", help="IMAP password (otherwise prompt)")
    ap_add.add_argument("--spam", help="Spam folder (default: Junk)")
    ap_add.add_argument("--important", help="Important folder (default: Important)")
    ap_add.add_argument("--newsletter", help="Promotions/newsletters folder (default: Promotions)")
    ap_add.add_argument("--projet", help="Projects folder (default: Projects)")
    ap_add.add_argument("--basse", help="Low priority / SocialNetwork folder (default: SocialNetwork)")
    ap_add.add_argument("--quarantine", help="Quarantine/review folder (default: AI/A-REVIEW)")
    ap_add.add_argument("--no-create-folders", action="store_true", help="Do not auto-create missing folders")
    ap_add.add_argument("--auto-move", action="store_true", help="Enable automatic moves (otherwise cold mode)")
    ap_add.add_argument("--auto-spam", action="store_true", help="Allow automatic move to Spam when over threshold")
    ap_add.set_defaults(func=add_account)

    ap_up = sub.add_parser("update", help="Update an account or folder mapping")
    ap_up.add_argument("name")
    ap_up.add_argument("--user")
    ap_up.add_argument("--host")
    ap_up.add_argument("--port")
    ssl_group = ap_up.add_mutually_exclusive_group()
    ssl_group.add_argument("--ssl", action="store_true")
    ssl_group.add_argument("--no-ssl", action="store_true")
    ap_up.add_argument("--spam")
    ap_up.add_argument("--important")
    ap_up.add_argument("--newsletter")
    ap_up.add_argument("--projet")
    ap_up.add_argument("--basse")
    ap_up.add_argument("--quarantine")
    ap_up.add_argument("--no-create-folders", action="store_true", help="Do not auto-create missing folders")
    ap_up.add_argument("--auto-move", action="store_true")
    ap_up.add_argument("--no-move", action="store_true")
    ap_up.add_argument("--auto-spam", action="store_true")
    ap_up.add_argument("--no-spam", action="store_true")
    ap_up.add_argument("--rotate-password", action="store_true", help="Change password (tests live)")
    ap_up.set_defaults(func=update_account)

    ap_rm = sub.add_parser("remove", help="Remove an account")
    ap_rm.add_argument("name")
    ap_rm.add_argument("--delete-secret", action="store_true", help="Also delete stored secret file")
    ap_rm.set_defaults(func=remove_account)

    ap_ls = sub.add_parser("list", help="List accounts")
    ap_ls.set_defaults(func=list_accounts)

    ap_test = sub.add_parser("test", help="Test IMAP connection for an account")
    ap_test.add_argument("name")
    ap_test.set_defaults(func=test_account)

    args = ap.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()
