"""Encrypted persistence for ``rules.yaml`` snapshots.

What:
  Provide an encrypted on-disk cache of the last known good rules document so
  that the engine can recover from IMAP outages or malformed updates.

Why:
  The configuration lives inside email bodies; transient network issues or user
  mistakes could leave the runtime without a valid policy. A local encrypted
  backup enables safe rollback without storing plaintext rules on disk, which is
  vital for deployments processing sensitive data.

How:
  Use the ChaCha20-Poly1305 helpers from :mod:`mailai.core.privacy` to encrypt
  and decrypt the YAML payload with a fixed-size key supplied via Docker
  secrets. The helper writes the ciphertext atomically and gracefully falls back
  to a minimal baseline policy when the backup is unavailable or corrupted.

Interfaces:
  - :class:`EncryptedRulesBackup`: High-level helper managing persistence.
  - :class:`BackupError`: Raised when decryption fails in a recoverable way.

Invariants:
  - Only encrypted blobs are ever written to disk; plaintext YAML remains in
    memory only for the duration of the call.
  - The backup directory is created eagerly to prevent race conditions during
    emergency restore operations.

Safety/Performance:
  - Errors from the crypto layer are wrapped so callers can decide whether to
    halt or continue with defaults.
  - The minimal baseline keeps runtime behaviour predictable even on
    under-provisioned Raspberry Pi devices where storage may be unreliable.
"""
from __future__ import annotations

from pathlib import Path

from ..core.privacy import decrypt, encrypt, KEY_SIZE
from ..config import yamlshim
from ..config.schema import RulesV2


class BackupError(RuntimeError):
    """Failure while reading or writing the encrypted rules backup.

    What:
      Signal to callers that the persisted ciphertext could not be decrypted or
      written.

    Why:
      Distinguishing backup failures from parser issues allows the caller to
      decide whether to fall back to defaults or surface a fatal error to the
      operator.

    How:
      Subclasses :class:`RuntimeError` so it integrates naturally with existing
      error handling without introducing a new dependency hierarchy.
    """


class EncryptedRulesBackup:
    """Manage encrypted snapshots of the last known good rules document.

    What:
      Expose helpers to save, retrieve, and query encrypted ``rules.yaml``
      backups.

    Why:
      The runtime needs a deterministic recovery path that protects confidential
      rules while still enabling offline restoration during IMAP downtime.

    How:
      Accept a filesystem path and symmetric key, ensure the destination exists,
      and leverage :func:`encrypt` / :func:`decrypt` helpers for the heavy
      lifting. When the ciphertext is missing or invalid the class yields the
      minimal baseline YAML generated by :func:`RulesV2.minimal`.

    Args:
      path: Target file path for the encrypted blob.
      key: Symmetric key used for ChaCha20-Poly1305 operations.

    Raises:
      ValueError: If the provided key length does not match :data:`KEY_SIZE`.
    """

    def __init__(self, path: Path, key: bytes):
        """Initialise the backup helper and guarantee the destination exists.

        What:
          Store constructor parameters and pre-create the parent directory so
          saves never fail due to missing folders.

        Why:
          Configuration restores often happen during degraded conditions; eager
          directory creation avoids introducing another failure mode when
          operators need the backup most.

        How:
          Validate the key size, normalise the :class:`~pathlib.Path`, and create
          parent directories with ``exist_ok`` to remain idempotent.

        Args:
          path: Desired file location for the encrypted payload.
          key: 32-byte symmetric key shared with the privacy subsystem.

        Raises:
          ValueError: If ``key`` is not exactly :data:`KEY_SIZE` bytes long.
        """
        if len(key) != KEY_SIZE:
            raise ValueError("Backup key must be 32 bytes")
        self._path = Path(path)
        self._key = key
        # SAFETY: Ensures later atomic writes succeed even during recovery from read-only mounts.
        self._path.parent.mkdir(parents=True, exist_ok=True)

    def save(self, yaml_text: str) -> None:
        """Persist a validated rules document as encrypted ciphertext.

        What:
          Encrypt the provided YAML text and write it to disk.

        Why:
          Persisting plaintext would leak sensitive classifier logic; encrypting
          maintains confidentiality while enabling fast restores.

        How:
          Encode the text as UTF-8 bytes, pass it through
          :func:`mailai.core.privacy.encrypt`, and write the resulting blob using
          :meth:`pathlib.Path.write_bytes`.

        Args:
          yaml_text: The already validated rules YAML document.
        """

        payload = yaml_text.encode("utf-8")
        blob = encrypt(payload, self._key)
        self._path.write_bytes(blob)

    def load_or_minimal(self) -> str:
        """Return the stored configuration or fall back to the minimal template.

        What:
          Load and decrypt the encrypted backup, defaulting to the baseline YAML
          when the file is missing or unreadable.

        Why:
          Restores must succeed even when the backup is absent or corrupted so
          that the engine can continue with safe defaults.

        How:
          Read the ciphertext, decrypt it with the configured key, and decode to
          UTF-8. Any filesystem or crypto errors either propagate as
          :class:`BackupError` (for decryption issues) or trigger a fallback to
          :func:`_minimal_yaml`.

        Returns:
          The decrypted YAML text or the minimal policy when no valid backup is
          available.

        Raises:
          BackupError: If decryption fails, signalling upstream logic to treat
          the blob as compromised.
        """

        try:
            blob = self._path.read_bytes()
        except FileNotFoundError:
            return _minimal_yaml()
        try:
            data = decrypt(blob, self._key)
        except Exception as exc:
            raise BackupError("Failed to decrypt rules backup") from exc
        return data.decode("utf-8")

    def last_known_good(self) -> str:
        """Retrieve the backup while swallowing decryption errors.

        What:
          Provide a resilience-oriented accessor that ignores corrupted backups
          and always returns usable YAML.

        Why:
          Some callers prefer a best-effort restore path rather than propagating
          exceptions during degraded conditions.

        How:
          Attempt to read and decrypt the ciphertext, but fall back to
          :func:`_minimal_yaml` when the file is missing or any exception is
          raised. This intentionally mirrors :meth:`load_or_minimal` but with a
          softer error handling contract.

        Returns:
          The decrypted YAML text or the minimal safe baseline.
        """

        try:
            blob = self._path.read_bytes()
        except FileNotFoundError:
            return _minimal_yaml()
        try:
            data = decrypt(blob, self._key)
        except Exception:
            return _minimal_yaml()
        return data.decode("utf-8")

    def has_backup(self) -> bool:
        """Report whether an encrypted backup currently exists on disk.

        What:
          Expose a convenience predicate for callers to gate recovery flows.

        Why:
          Avoids leaking filesystem layout details to higher layers and keeps
          backup-related logic encapsulated.

        How:
          Delegate to :meth:`pathlib.Path.exists` on the configured target.

        Returns:
          ``True`` when an encrypted snapshot is present, otherwise ``False``.
        """

        return self._path.exists()


def _minimal_yaml() -> str:
    """Return the baseline safe configuration used when no backup is available.

    What:
      Generate a deterministic minimal rules document encoded as YAML text.

    Why:
      Ensures the engine can bootstrap with known-safe defaults when the backup
      is missing, unreadable, or fails validation.

    How:
      Call :meth:`RulesV2.minimal` to create the pydantic model and serialise it
      with the repository's YAML shim for consistent formatting.

    Returns:
      YAML text representing the minimal configuration.
    """

    minimal = RulesV2.minimal()
    return yamlshim.dump(minimal.model_dump(mode="json"))


# TODO: Other modules require the same treatment (Quoi/Pourquoi/Comment docstrings + module header).
